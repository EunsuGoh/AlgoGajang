/* 문제 설명
큰 수의 법칙
다양한 수로 이루어진 배열이 주어질 때
주어진 수를 M번 더하여 가장 큰 수를 만드는 법칙이다.
배열의 특정 인덱스에 해당하는 수가 연속해서 K번을 초과해 
더해질 수 없다.

입력조건
* 첫째 줄 N(2 <= N <= 1000), M(1 <= M <= 10000), K(1 <= K <= 10000)
의 자연수가 주어지고, 자연수는 공백으로 구분한다.
* 둘째 줄 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의
자연수는 1이상 10000이하의 수로 주어진다.
* 입력으로 주어지는 K는 항상 M보다 작거나 같다.

출력조건
* 첫째 줄에 동빈이의 큰 수의 법칙에 따라 더해진 답을 출력한다.

입력예시
5 8 3
2 4 5 4 6 

출력예시
46
*/

/* 입력 조건 변경
문제에서 N은 배열 크기로 주어졌으나
애초에 배열이라고 바꿔서 풀었음
*/

/* 발상
 * 입력 받은 배열에서 가장 큰 수와, 두 번째 큰 수를 저장한다.
 * K번 초과를 피하기 위해 두 번째 큰 수가 필요하다.
 */

// 풀이
function largestNum(N, M, K) {
  let sortedArr = N.sort((a, b) => b - a); // 배열을 내림차순으로 정렬
  let firstNum = sortedArr[0];
  let secondNum = sortedArr[1];
  let result = 0;
  let count = 0; // 큰 수가 반복해서 몇번 쓰였는지 확인용
  while (M > 0) {
    M--;
    count++;
    result += firstNum;
    // 큰 수가 K번 초과하는 경우 두 번째 큰 수를 더해준다.
    if (count === K) {
      M--;
      count = 0;
      result += secondNum;
    }
  }
  return result;
}

console.log(largestNum([2, 4, 5, 4, 6], 8, 3));
